\documentclass{book} 
\usepackage[spanish]{babel} 
%\usepackage [T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}

\usepackage{url}
\usepackage{hyperref}
\usepackage{listings} % Activar formato codigo

\usepackage{eurosym} % Símbolo para el euro
\DeclareInputText{164}{\euro}

\usepackage{dcolumn} % Formato Tabla
\usepackage{colortbl} 
\usepackage{longtable}
\usepackage{tabularx}



\usepackage{color}	% Formato codigo
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}
 
\usepackage{listings}
\lstset{ frame=Ltb,
     framerule=0pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.4cm,
     framesep=0pt,
     rulesep=.4pt,
     backgroundcolor=\color{gray97},
     rulesepcolor=\color{black},
     %
     stringstyle=\ttfamily,
     showstringspaces = false,
     basicstyle=\small\ttfamily,
     commentstyle=\color{gray45},
     keywordstyle=\bfseries,
     %
     numbers=left,
     numbersep=15pt,
     numberstyle=\tiny,
     numberfirstline = false,
     breaklines=true,
   }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fixmes
%% macros: \fixme -critical-, \fxerror -noncritical-, \fxwarning, \fxnote
%% env: afixme, anfxerror, anfxwarning, anfxnote
% % \usepackage[marginclue,inline]{fixme}
\usepackage[inline,nomargin,draft]{fixme}
%% \usepackage[marginclue,footnote]{fixme}
\usepackage{framed}
%%\renewcommand{\FXInline}[2]{\noindent{\color{red}#1: \emph{\small #2}}}
%%\renewcommand{\FXMarginClue}[1]{\marginpar{\footnotesize\raggedleft\textbf{\color{red}#1~!}}}
%%\renewcommand{\FXEnvBegin}{\begin{framed}\begin{small}\color{red}}
%%\renewcommand{\FXEnvEnd}{\end{small}\end{framed}}


\begin{document} 

\title{Adaptación servicios web BetFair al sistema móvil iOS}
\author{Francisco Miguel Merchan Casado}
\date{Enero de 2010}                                           % Activate to display a given date or no date


\begin{titlepage}
\begin{center}
	{\Large UNIVERSIDAD POLITÉCNICA DE MADRID}\\[2cm]
	{\Large FACULTAD DE INFORMÁTICA}\\ [4cm]
	{\Large Trabajo de Fin de Carrera}\\[1cm]
	
	{\Huge Adaptación de servicios web BetFair al sistema móvil iOS}\\[8cm]
	
	{\Large AUTOR: Francisco Miguel Merchán Casado}\\
	{\Large TUTOR: Ángel Herranz Nieva}\\
\date{Enero de 2012}
\end{center}
\end{titlepage}

%{\Large Indice de contenidos}\\
\tableofcontents
\newpage
%\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Resumen}
\addcontentsline{toc}{chapter}{Resumen}
En este documento se describe el trabajo de fin de carrera acerca del desarrollo de una aplicación de apuestas de BetFair para los dispositivos iOS\footnote{iPhone Operating System}. Esta aplicación contiene las siguientes funcionalidades:
\begin{itemize}
    \item Consultar los eventos de Betfair por los que se puede apostar.
    \item Apostar sobre los eventos.
    \item Realizar seguimientos a la evolución de los mercados.
    \item Asesoramiento para realizar  \emph{tradings}  sobre apuestas ya realizadas.
  \end{itemize}
        
     En el capítulo \ref{ch:intro} se presentan los conceptos básicos
    de las apuestas deportivas.
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{X} 
\bibitem{Baz} {\sc Bazaraa, M. S.}, {\sc J. J. Jarvis} y {\sc H.
D. Sherali}, {\it Programación lineal y flujo en redes}, segunda
edición, Limusa, México, DF, 2004. 
\bibitem{Dan} {\sc Dantzig, G. B.} y {\sc P. Wolfe},
<<Decomposition principle for linear programs>>, {\it Operations
Research}, {\bf 8}, págs. 101--111, 1960. \end{thebibliography}

\chapter{Introducción}
\label{ch:intro}

En este capítulo, se introduce al lector en el dominio de las apuestas deportivas en Internet y se presenta el terminal elegido como plataforma de la aplicación de apuestas, resultado del presente trabajo de fin de carrera.

\section{Apuestas por Internet}

%\fxnote{``Mundo de la apuestas'' es demasiado genérico}

%\fxnote{Yo hablaría de apuestas, de casas de apuestas tradicionales y de su entrada en Internet. Pondría ejemplos sobre lo que se puede y no se puede hacer para que el lector se familiarice.}

%\fxnote{Luego hablaría del concepto de ``casa de intercambios'' en las que el ``bookie'' no es la casa si no cualquier otro apostador. La idea, como dices en algún momento es simple: los apostadores pueden apostar a favor (significado habitual de apostar) o en contra (con el significado de cubrir una apuesta a favor).}

%\fxnote{Recuerda este enlace en el que hay dos documentos que creo que pueden ayudar con esta presentación del dominio del problema: \url{http://www.iapuestas.com/Guia/introduccionintercambiodeapuestas.asp} y \url{http://www.iapuestas.com/Guia/lasmatematicasdelasapuestas.doc}. Quizá pueda salir algo de \url{http://www.sportsbookreview.com/Espanol/Default.aspx}, \url{http://internetgamblingreport.com/ o http://anjaander.blogspot.com/} o incluso \url{http://en.wikipedia.org/wiki/Bet_exchange}}

Actualmente las apuestas tienen gran aceptación en todo el mundo. En España ya hay una tradición de bastantes años por la quiniela y la lotería. En la quiniela, por ejemplo, nunca sabemos por anticipado cuánto cobraremos en caso de acierto ya que depende del número de participantes que hayan acertado el resultado de la jornada de la Liga Profesional de Fútbol. Un acierto de 13 resultados puede convertirse en una gran decepción por el premio conseguido si junto con nosotros han acertado el resultado otras 100 personas. Sin embargo, si eres el único acertante ya no tienes que repartir el premio. En las casas de apuestas tradicionales el apostante cruza su apuesta directamente contra la propia casa. En un típico ejemplo tenemos las clásicas carreras de caballos sobre las que se apuesta sobre un caballo ganador. La casa de apuesta tradicional se limita siempre a cubrir nuestras apuestas. 


En los últimos años hemos sido testigos de la llegada de las llamadas casas de intercambio. 
%\fxnote{no creo que estén desfasadas} 
% \fxnote{Tb. puedes decir que la casa ``cubre'' la apuesta.}. 
Las casas de intercambio añaden un nuevo concepto en el mundo de las apuestas. Los usuarios realizan las apuestas sobre los eventos y entre ellos mismos se cubren las apuestas, es decir, los apostantes pueden realizar apuestas a favor o en contra de los eventos. 
%\fxnote{Falso, las cuotas y cantidades a apostar existen siempre}
 En este caso, la casa de apuestas hace de intermediario obteniendo un porcentaje en la ganancia del apostante. %\fxnote{Creo que hace falta decir que los apostantes apuestan a favor y en contra} 
 Las ventajas de las casas de apuestas de intercambio con respecto a las tradicionales son:
\begin{itemize}
	\item Las comisiones son menores que las correspondientes a una casa de apuestas tradicionales.
	\item Cuanto mayores sean las cantidades apostadas, mayor será la comisión que se lleve la casa de intercambio, es por eso que no suelen existir límites en las cantidades a apostar en contra de las casas de apuestas tradicionales siempre y cuando se cubra una apuesta a favor con otro en contra.%\fxnote{Pero existen límites que pueden ser inferiores a los de las casas normales, si nadie apuesta en contra o a favor, por ejemplo.}
\end{itemize}
Pero como en toda comparación siempre hay desventajas: 
\begin{itemize}
	\item Normalmente, debido a las nuevas posibilidades de apuesta de las casas de intercambio se requieren conocimientos avanzados y una mayor experiencia para obtener beneficios en contraposición a la simplicidad que ofrecen las casas de apuestas tradicionales.
	\item En las casas de intercambio son los propios usuarios los que proponen sus apuestas y los mercados tardan más tiempo en abrirse. Entendemos por mercado el evento deportivo por el cual podemos apostar a favor o en contra. Por ejemplo, en un partido de tenis apostar por cúal de los dos jugadores va a ganar. En las casas de apuestas tradicionales es la propia casa la que establece las cuotas abriendo los mercados más rápidamente.
\end{itemize}

Debido a la aparición de estas casas de intercambio, aparecen dos nuevas modalidades para realizar apuestas. La primera el poder realizar apuestas en contra de un evento (\emph{lay})  diferenciándose claramente de las casas de apuestas tradicionales donde sólo se pueden realizar apuestas a favor (\emph{back}) de un evento.
 La segunda modalidad es la facilidad para realizar \emph{trading}, concepto que desarrollaremos en el siguiente apartado.
 %\fxnote{El trading es algo que tb se puede hacer en las casas normales, habitualmente utilizando varias casas}  

 \subsection{Apuestas Back y Lay}
 
   Para un mejor entendimiento y comprensión de la temática de este trabajo de fin de carrera, definiremos los principales conceptos en una apuesta:
 \begin{itemize}
 \item Bankroll: es la cantidad de dinero o capital  que estamos dispuestos a apostar. Lógicamente tendremos que administrarlo de la mejor manera posible, minimizando las pérdidas en caso de perder una apuesta y maximizar las ganancias de una apuesta ganadora. La disciplina y el conocimiento del mercado son las mejores aliadas de nuestro bankroll. La mayoría de las casas de apuestas por Internet nos regalan un mínimo bankroll para animarnos a participar en ellas.
 \item Stake: es la cantidad de dinero que ofrecemos por un determinado evento en la apuesta . Es decir, apostar 10 euros a que gana el Sevilla F.C el campeonato de la Liga Profesional de Fútbol.
 \item Odds: es la cuota (probabilidad) de una apuesta. Por ejemplo se paga una cuota de 3 a 1 que Fernando Alonso gane el mundial de Fórmula 1. Nos refleja que Fernando Alonso tiene más probabilidades de ganar el campeonato que no ganarlo.
 \item Beneficio: es la ganancia que obtenemos de una apuesta ganadora cuyo cálculo es el siguiente:
 \begin{displaymath}
 Beneficio = (stake \times odd) - stake 
\end{displaymath}

%\begin{anfxnote}
%  Latex es famoso por la potencia a la hora de escribir fórmulas   matemáticas:
%
%\begin{displaymath}
%  B = s \times o
%\end{displaymath}
%
%\end{anfxnote}

\item Pérdida: lógicamente lo opuesto al beneficio. Lo que todo apostante quiere evitar o minimizar. 
\item Yield: expresado en porcentaje. Nos indica el beneficio obtenido del total apostado. Es lo que diferencia a un buen apostador del resto. El cálculo es el siguiente:
\begin{displaymath}
 Yield = (beneficio / total apostado) \times 100 
\end{displaymath}
\end{itemize} 


 
 \subsection{Trading}
 
  Se trata de apostar a favor y en contra sobre un mismo evento obteniendo así una ganancia segura en unos casos o minimizar la pérdida en otros.  Esta modalidad se puede realizar en la casa de apuestas tradicionales pero para ello necesitas usar varias casas. Es decir, en una casa cubre la apuesta a favor de un evento mientras que otra casa ve más interesante cubrir la opuesta. Este término también se suele usar en operaciones financieras, como por ejemplo la Bolsa.
  
  
  Este método se suele dar en dos escenarios típicos:
  
  
\begin{itemize}
	\item Ganancia segura.
	  Se suele llamar apuesta segura, es decir cualquiera que sea el desenlace del evento, nunca se pueda perder. La condición necesaria para ello es que la cuota de la apuesta a favor sea superior a la cuota de la apuesta en contra. 
	\item Minimizar la pérdida.
	   Lo contrario que el punto anterior. Es decir, el mercado evoluciona de tal manera que la cuota de la apuesta en contra es mayor que la ya realizada a favor. En este caso lo que se persigue es minimizar la pérdida segura.
\end{itemize}

%\fxnote{Tienes que pensar en el lector, imagina a alguien que entiende de probabilidades pero que jamás ha hecho una apuesta.}
%\fxnote{Hay que meter más secciones, aquí empezaría el ``trading''}

A continuación exponemos un ejemplo de caso típico de \emph{trading}.
%\begin{figure} [h]
%  \centering
%    \includegraphics[width=0.6\textwidth]{./images/SampleTrading1.png}
%  \caption{Situacion inicial}
%  \label{fig:Inicio}
%\end{figure}
 Nos basaremos en las apuestas deportivas sobre un partido de tenis.
 
 \begin{center}
    \begin{tabular}{| c | c | c l}
      \hline
      \hline
      players & A favor & En contra\\
      \hline
      \hline
      Rafa Nadal & 2.18 & 2.2\\
      \hline
      \hline
      Roger Federer & 1.8 & 1.85\\
      \hline
      \hline
    \end{tabular}
  \end{center}

%\fxnote{Hay que explicar el significado de la figura, ¿qué son esos números? ¿qué significan?}

En la tabla
% \fxnote{En Latex jamás escribes un número, todo son referencias: \ref{fig:Inicio}}, 
podemos ver las cuotas a favor y en contra de un partido de tenis entre Rafa Nadal y Roger Federer. La cuota a favor de Rafa Nadal está mucho más alta que la de Roger Federer.  En el mundo de las apuestas, influyen todos los pequeños factores que al aficionado se les escapa. Supongamos que Nadal pierde el primer set, esto desemboca en cambios en la tabla de apuestas. %\fxnote{Es inconsistente, si Nadal pierde el primer set se pagaría más alto que al principio del partido.}

  Vemos ahora que el mercado ha cambiado. Ahora mismo se refleja una 
  %\fxnote{¿clara?} 
  ventaja para la victoria de Roger Federer.
   
 \begin{center}
    \begin{tabular}{| c | c | c |}
      \hline
      \hline
      players & A favor & En contra\\
      \hline
      \hline
      Rafa Nadal & 2.5 & 1.2\\
      \hline
      \hline
      Roger Federer & 1.5 & 2\\
      \hline
      \hline
    \end{tabular}
  \end{center}
  
  
  %\begin{figure} [h]
   % \centering
   %    \includegraphics[width=0.6\textwidth]{./images/SampleTrading2.png}
   %  \caption{Situacion cambiante}
   %\label{fig:Inicio}
%\end{figure}

Al inicio del ejemplo realizamos una apuesta a favor de Rafa Nadal por 50 euros, con lo que tendríamos:

%\fxnote{¿Por qué apostar a favor de Nada? ¿Sabemos algo que nadie sabe? ¿Intuímos algo? ¿Tenemos datos estadísticos?}   	
	 
\begin{displaymath}
  Beneficio = (1.8 \times 50) - 50 =  40 \euro  
\end{displaymath}

Por lo que tenemos 40 euros si ganal Nadal, en caso contrario:
 
 \begin{displaymath}
  Riesgo = - 50 \euro 
\end{displaymath}
Tendremos una pérdida de 50 euros si pierda Nadal.
	
Un tiempo más adelante, el mercado ha cambiado debido al resultado del primer set, Nadal ya no es tan favorito para la victoria.
  
Para asegurar el dinero apostado anteriormente realizamos una apuesta en contra de Nadal. De tal forma que nos queda:
  \begin{displaymath}
  Beneficio = 70 \euro 
  \end{displaymath} euros si pierde Nadal.
   \begin{displaymath}
  Riesgo = 70 - (1.2 \times 70) = -14 \euro
  \end{displaymath} euros si gana Nadal.
  
	 
Al final si gana Rafa Nadal obtenemos: 
   \begin{displaymath}
   40 - 14 = 26 \euro 
   \end{displaymath}
   
Si pierde Nadal y por tanto gana Roger Federar tenemos:
   
  \begin{displaymath}
  70 - 50 = 20 \euro
  \end{displaymath}
       
   Con lo que estamos cubiertos ante cualquier resultado del partido. En ambos casos tenemos ganancias. 
   
   El escenario expuesto es uno de los mejores casos que nos pueden dar ya que obtenemos beneficio en ambos casos. Pero puede suceder que hayamos apostado por un evento con demasiada confianza y luego en un futuro vemos que puede ser una ruina. En ese escenario, el objetivo prioritario sería minimizar la pérdida apostando en contra del evento en cuestión.

 Las casas de apuestas nos ofrecen una gran variedad de apuestas en diferentes deportes que nos permiten adecuarnos a nuestros gustos y conocimientos. 
   
\section{Betfair}

 Debido al gran desarrollo de Internet en los principios de siglo empiezan a aparecer las primeras casas de intercambio %\fxnote{Casas de apuestas y casa de intercambio, creo que son dos concpetos diferentes, bwin es una casa de apuestas tradicional, betfair es una casa de intercambios de apuestas}
  online. Betfair\footnote{\url{www.betfair.com}}, Bwin\footnote{\url{www.bwin.com}}, Miapuesta.com\footnote{\url{http://www.miapuesta.com}} son ejemplos de casas afianzadas en Internet. % \fxnote{Ésto que dices no está claro: \url{http://www.sportsbookreview.com/Espanol/Default.aspx}}.
   Dentro de este grupo selecto aparece Betfair.%\fxnote{No creo que sea cierto y si lo es necesitamos una fuente fiable. Tenemos que tener cuidado, hemos de contrastar la información. ¿En qué sentido es la más grande?}.
 
%\fxnote{Please, menos marketing. Esto es un TFC, un documento eminentemente técnico.}

 Betfair fue fundado en Junio del año 2000. Es una de las primeras casas de apuestas online en ofrecer la modalidad de apuestas a favor y en contra de un evento. En el año 2007 la casa ya cuenta con más de 1.000.000 de usuarios generando un volumen de negocio de más de 50 millones de libras a la semana. Rápidamente se expande en más de 120 países de todo el mundo ofreciendo un portal web en 18 idiomas que gestiona más de 5 millones de transacciones al día. %\fxnote{Fuente?}

%\fxnote{No deberíamos explicar antes que el interfaz es Web y que e 2007 bla bla bla?}

En el año 2007, Betfair es el primer portal de apuestas que ofrece un API\footnote{Application Programming Interface} %\fxnote{Footnote demasiado largo}
 de acceso a sus servicios. El API de Betfair lo explicaremos con más detalle en el capítulo \ref{ch:diseno}. La estrategia es clara, enganchar a los desarrolladores para crear todo tipo de aplicaciones usando su portal de apuestas como base y que se adapten a cualquier dispositivo sea tanto un ordenador personal, agenda electrónica o dispositivo móvil. Como era de esperar, empezaron a salir multitud de aplicaciones, sobre todo dirigidas al sector de usuarios expertos en apuestas. Ahora, con las nuevas tecnologías móviles, el usuario busca realizar consultas en todo momento de sus servicios contratados. Ya sea email, servicios del banco, entradas de cine\ldots %\fxnote{\ldots para poner puntos susepnsivos} 
% \fxnote{Esta última frase quedaría mejor para lo del iPhone}

%\fxnote{Has pasado muy de puntillas por lo del API de BF y parece importante para tu TFC.}

\section{Apple y su terminal móvil iPhone}
 
Apple Computer, Inc. es una empresa estadounidense de tecnología informática fundada en 1976. Inició sus trabajos sobre los ordenadores personales en la década de los setenta con el ordenador Apple II y reinventó el ordenador personal en los ochenta con el Macintosh. Hoy en día, Apple es considerada como una de las principales empresas líderes en innovación con sus ordenadores.  %\fxnote{Please, menos marketing.}

El 23 de octubre de 2001, Apple decidió introducirse en la industria musical con su famoso reproductor de música \emph{iPod} y su tienda de discos \emph{iTunes}.

El 9 enero del año 2007 presenta su primer terminal móvil llamado \emph{iPhone}. Tal y como lo hizo años atrás en la industria musical, su terminal se hizo famoso en la industría de la telefonía móvil por su diseño, su sistema operativo \emph{iPhone OS} y la introducción de nuevas tecnologías como la pantalla táctil.

\begin{figure} [h]
  \centering
    \includegraphics[width=0.6\textwidth]{./images/iphone4.jpg} 
  \caption{iPhone 4GS}
  \label{fig:iPhone-4GS}
\end{figure}
  
  En marzo de 2008 Apple muestra una nueva versión del terminal con tecnología 3G y comunica el lanzamiento de su propia tienda de aplicaciones para el iPhone, la \emph{iTunes application store}. Para nutrir esa tienda de aplicaciones  lanza un conjunto de herramientas de desarrollo iPhone SDK\footnote{Software Development Kit} para todos aquellos desarrolladores que quieran participar en la misma. En el capítulo \ref{ch:diseno}  explicamos con más detalle dicho SDK ya que es una pieza clave en el presente trabajo de fin de carrera. %\fxnote{Y sin embargo esta parte es fundamental: ¿Qué es el SDK? ¿Cómo es? ¿Quién puede usarlo? ¿Cómo se programa? etc. etc. etc.}
  
   Otro hito importante a destacar ocurre el 27 de enero de 2010. Apple amplía la familia de dispositivos con una tableta táctil de 10 pulgadas denominada \emph{iPad}. Misma filosofía pero ahora en formato de pantalla más grande. De la misma forma que evoluciona sus dispositivos, evoluciona el \emph{SDK} para ofrecer a los desarrolladores las herramientas necesarias para crear aplicaciones compatibles entre la familia de dispositivos. A partir de 2010 el sistema operativo de los dispositivos para a denominarse \emph{iOS}. 
    
  Hoy en día, Apple dispone de un catálogo de más de 500.000 aplicaciones disponibles en su tienda\footnote{Fuente: www.apple.com y http://148apps.biz/app-store-metrics/} y más de 316 millones de terminales vendidos por todo el mundo.\footnote{Fuente: www.apple.com} He aquí la importancia de la temática de este trabajo de fin de carrera, adaptar el acceso de los servicios de Betfair a la plataforma móvil ofrecida por Apple.  Ha llegado el momento de las aplicaciones en los dispositivos móviles.
    
   
\section{Objetivos}

%\fxnote{Mover como sección del capítulo anterior}

 Los objetivos que se pretenden cubrir con el actual trabajo de fin de carrera son los siguientes:
 \begin{itemize}
 	\item Explorar y adaptar el API de Betfair para la plataforma iPhone.
 	\item Posibilidad de navegar y apostar por eventos del portal betfair.com a través del terminal móvil.
	\item Asesorar al usuario sobre cuando realizar el trading a las apuestas ya realizadas.
\end{itemize}

%\fxnote{Objetivos, desde mi punto de vista: (1) explorar el API de acceso a los servicios web de Betfair para (2) desarrollar una aplicación para iPhone que (i) permita navegar a través de los mercados de apuestas de BF, (ii) permita realizar apuestas, (iii) y asesore al usuario (de forma incluso automática) sobre posibilidades de trading.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Requisitos}
\label{ch:requisitos}
%\fxnote{En este capítulo, bla bla bla}
En este capítulo se presentan los requisitos a cumplir por la aplicación. Comenzaremos explicando el escenario al que pertenece la aplicación y terminaremos presentando las historias de uso de la misma.
\section{Escenario}
%\fxnote{¿Qué signfica ``escenario'' aquí? La palabra escenario tiene un significado muy claro en la ingeniería de requisitos y suelen ser descripciones de situaciones de uso de la aplicación.}

El escenario que se pretende %\fxnote{corrección ortográfica?} 
cubrir con la aplicación es la posibilidad de navegar y realizar apuestas sobre eventos deportivos del portal Betfair.com. Se pretende cubrir las funcionalidades básicas que ofrece Betfair en su portal web para poder realizar apuestas. %\fxnote{Cuidado, las funcionalidades son importantes a través de la web, nosotros no las hemos implementado todas.}

%\section{Historias de usuario}

%\fxnote{Otra idea puede ser referirnos al interfaz web para dejar claras algunos requisitos.}

%\fxnote{Entre los requisitos llamados habitualmente ``no funcionales'' (odio el adjetivo) está el de adaptar la forma en la que se muestra la información a las limitaciones y capacidades del propio terminal.}

%\fxnote{¿Qué vas a contar aquí? ¿Qué significa ``historias de uso''? ¿No será ``historias de usuario''? ¿Vas a seguir algún ``estándar''? ¿XP? Como ejemplo: en \url{http://en.wikipedia.org/wiki/User_story} puedes encontrar algo de texto introductorio, incluidas ventajas e inconvenientes. En \url{http://www.agilemodeling.com/artifacts/userStory.htm} puedes encontrar más detalle sobre cómo hacerlas. En el TFC de Antonio puedes encontrar incluso macros latex para que aparezcan más bonitas.}

%\fxnote{Entre los requisitos puedes añadir seguir alguna guía de estilo de Apple o del desarrollo para iPhone (que no se si existen).}

\section{Historias de usuario}
%\fxnote{Mejor ``Historias de Uso''}
\subsection{Instalación} Para poder instalar la aplicación sólo se necesitará una cuenta del programa iTunes Store de Apple. Es gratuita. La aplicación estará disponible dentro del programa App Store del dispositivo. Solamente habrá que descargar la aplicación de dicho portal. Alternativamente podemos descargarla también desde el programa iTunes para Windows y Mac. Una vez descargada podemos transferirla al dispositivo sincronizando mediante Wifi o cable USB. %\fxnote{¿No existen otras forma de instalar las aplicaciones?}
\subsection{Actualizar la aplicación}
La aplicación  App Store  del dispositivo será la encargada de comunicar al usuario la aparición de una nueva versión del aplicativo. Para actualizarla simplemente habrá que seguir las indicaciones de dicho programa. %\fxnote{Lo mismo  de antes}

\subsection{Desinstalar}
Para desinstalar la aplicación simplemente se mantiene pulsado el icono de la misma unos segundos hasta que el icono empiece a vibrar. Inmediatamente pulsamos sobre el icono X que aparecerá es la esquina superior izquierda del icono de la aplicación. %\fxnote{¿qué es la ``X''? ¿es estándar?} que aparecerá sobre la misma.
\subsection{Ejecución}
Para lanzar la aplicación sólo hay que pulsar el icono que aparece en la pantalla principal del dispositivo.
\subsection{Configurar la aplicación}
Se podrán configurar los diferentes aspectos de la aplicación tales como el idioma o las credenciales de usuario a través del menú de ajustes del dispositivo. En el caso de ser la primera vez que se lance la aplicación, ésta automáticamente redirigirá al usuario a dicha pantalla para configurarla.
\subsection{Gestión de los eventos}
Se podrá navegar y obtener información de todos los eventos deportivos disponibles del portal Betfair a través una  %\fxnote{más bien de ``una''}
 jerarquía de menús de la aplicación siguiendo las hojas de estilo de interfaz de usuario de Apple.% \fxnote{¿Qué es un evento?}
\subsection{Realizar una apuesta}
%\fxnote{Recuerda que esto son requisitos, no el manual de usuario. Debemos decir lo que la aplicación ``va'' a permitir o lo que esperamos de ella. El ``cómo'' está más adelante.}
La aplicación permitirá la realización de una apuesta sobre un evento específico incluyendo la cantidad y cuota deseada. El sistema notificará al usuario el resultado de la operación.
\subsection{Gestionar las apuestas}
La aplicación será capaz de recopilar todas las apuestas realizadas sobre Betfair. Por cada apuesta, el sistema mostrará las opciones disponibles: información detallada de la apuesta, asesoramiento para trading y estado actual del mercado. %\fxnote{¿Que son?}
\subsection{Realizar trading sobre una apuesta ya realizada}
El sistema será capaz de asesorar para realizar trading sobre una apuesta ya realizada anteriormente. Para ello, se mostrará una tabla con las opciones disponibles dentro del resumen de una apuesta ya realizada. Se podrán configurar los tradings para que se lancen automáticamente por parte de la aplicación.

%\fxnote{Aunque no acabemos implementando, el asesoramiento para trading automático debería estar en la lista de requisitos.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Diseño}
\label{ch:diseno}
%\fxnote{Puede resultar conveniente cambiar el título a ``Diseño'' dado
 % que no existe un capítulo de análisis el salto desde requisitos a
 % arquitectura parece excesivo.}

%\fxnote{Mete un label en cada capítulo para poder referirnos a él.}

En este capítulo se presentará el diseño de la aplicación. Para un mejor entendimiento explicaremos brevemente el diseño interno de un dispositivo iOS conocido técnicamente como Cocoa Touch. Seguiremos por una breve descripción del API de acceso a los servicios de Betfair y concluiremos con una explicación detalla de la arquitectura desplegada en la aplicación.


\section{Descripción general}
 
  El análisis de los requisitos presentados en el capítulo \ref{ch:requisitos} %\fxnote{meter el label en el capítulo adecuado}
   dará como resultado la arquitectura de la aplicación. Para llevar a cabo su desarrollo, hemos tenido en cuenta la arquitectura del dispositivo y las herramientas adjuntas para el desarrollo de aplicaciones. Todas las decisiones tomadas en la construcción de la arquitectura de la aplicación se han basado en los límites o restricciones impuestas por el uso de la arquitectura de Apple y los límites impuestos en el uso del API de Betfair. Para comprender mejor el diseño de la aplicación expondremos brevemente la arquitectura impuesta por Apple en el iPhone y la tecnología en la que se basa el API que ofrece Betfair para el uso de sus servicios.

\section{API de iPhone/iPod Touch: Cocoa Touch}
 La arquitectura del terminal móvil se basa en su sistema operativo \emph{iOS} de Apple. Este sistema operativo, a grandes rasgos, es un subconjunto del sistema operativo que llevan los ordenadores personales de Apple. Esta decisión favorece el desarrollo de aplicaciones para sus plataformas. Simplifica la tarea a los desarrolladores de aplicaciones de ordenadores de sobremesa de Apple de programar aplicaciones móviles sin necesidad de aprender un lenguaje o arquitectura totalmente nueva.
 
 El iOS es capaz de ejecutar dos tipos de aplicaciones: 
\begin{itemize}
\item Aplicaciones nativas: 
aquellas aplicaciones que usan bibliotecas del sistema para su ejecución. 
\item Aplicaciones web: desarrollos basados % \fxnote{por?} 
en lenguajes de programación de páginas web y sólo se ejecutan al acceder por el navegador de Internet del dispositivo. Sorprende la capacidad de ciertos desarrolladores para generar aplicaciones con un look\&feel muy parecido a las aplicaciones nativas. Por supuesto, para su ejecución requieren de una conexión de datos hacia Internet.
 \end{itemize}

 %\fxnote{La introducción de gráficos o figuras puede hacerse de dos
  % formas: o la ``empotras'' directamente como he hecho yo con la
   %figura de las capas del OS o la metes en un entorno ``figure'' y la
   %referencias con un ``ref'' como he hecho con la figura \ref{fig:API
    % Betfair}, lo que creas más conveniente}

\noindent
La siguiente figura muestra la estructura de capas del iOS:

%\begin{center}
%  \includegraphics[width=0.5\textwidth]{./images/overview_systemlayers.jpg}
%\end{center}

\begin{figure} [h]
  \centering
    \includegraphics[width=0.6\textwidth]{./images/overview_systemlayers.jpg}
  \caption{Capas del iOS}
  \label{fig:Capas-del-iOS}
\end{figure}

En la parte baja del sistema se encuentran las capas encargadas de los
servicios fundamentales que permiten la ejecución de las aplicaciones,
y en las superiores contienen las capas sobre los servicios multimedia
y de las más altas tecnologías.
 

A continuación expondremos una breve descripción de cada capa:

%\fxnote{He cambiado el entorno ``itemize'' a ``description'' para que
 % veas como queda, si te gusta lo mantienes, si no lo cambias. También
 % he modificado la indentación en el código fuente de latex para que
 % veas que se pueden meter cambios de linea sin probleamas (dos
 % cambios de linea consecutivos = nuevo párrafo).}

\begin{description}
\item[Core OS.]  Es la capa que contiene el núcleo de
  sistema (\emph{kernel}) %\fxnote{Recuerda, inglés enfatizado, al
   % menos en la primera aparición, encárgate tú del resto.},
  , los controladores para dispositivos internos y las interfaces básicas del sistema
  operativo. El kernel es el responsable de todos los aspectos
  relacionados con el sistema operativo. Es el encargado de gestionar
  la memoria virtual, \emph{threads} (procesos ligeros), sistema de ficheros,
  red y procesos de comunicación. Los controladores son los encargados
  de proporcionar la interfaz entre el \emph{hardware} y los \emph{frameworks} de
  las capas superiores.
\item[Core Services.] Es la capa responsable de proporcionar los
  servicios básicos del sistema a las aplicaciones para su uso. En
  ella encontramos el acceso a la agenda del dispositivo, la gestión
  de estructura de datos, la gestión de las interfaces de red, la
  gestión de la localización del dispositivo, la gestión de la seguridad
  del sistema y el soporte para bases de datos SQL y XML.
\item[Media.] Es la capa encargada de dar soporte a las
  tecnologías de gráficos y al audio y video para proporcionar al usuario
  los medios multimedia vistos en un dispositivo móvil.
  %\fixme{No marketing, please.}. 
  Aún más importantes que las tecnologías
  en sí, es el hecho de que esta capa fue diseñada para facilitar al desarrollador su uso
  para crear aplicaciones con una gran apariencia en su interfaz de
  usuario y una reproducción de audio. %\fixme{No marketing.}.
\item[Cocoa Touch.]  Es una de las capas más importantes del iOS
  para un desarrollador. %\fxnote{desde el punto de vista del desarrollador, supongo}. 
  Es la encargada de proveer los objetos básicos necesarios para la
  implementación de aplicaciones. La puerta de acceso de los desarrolladores
  para el uso de los servicios de las anteriores capas.
\end{description}

%\fixme{El siguiente párrafo no se entiende bien, al menos yo no lo
  %entiendo bien del todo.}
  
  Esta última capa es la que diferencia la plataforma móvil de la plataforma PC en los entornos de Apple. Es el API que nos ofrece %\fxnote{ofrece-ofrece} 
  Apple para el uso de las tecnologías asociadas a un dispositivo móvil, especialmente en el uso de la tecnología táctil. En ella podemos encontrar los siguientes frameworks%\fxnote{¿es la footnote una definición de ``framework''?}
  \footnote{Un framework es una estructura de soporte definida, en la cual otro proyecto de software puede ser organizado y desarrollado.}: 

%\fxnote{Probablemente usaría description en vez de itemize.}

 \begin{description}
 	\item [UIKit.] Contiene todas las clases necesarias para la programación de la interfaz de usuario de las aplicaciones así como el acceso a las principales tecnologías hardware % \fxnote{no me gusta el palabro ``tecnologías físicas''}
	 propias del dispositivo  móvil:
		 \begin{itemize}
 			\item soporte para copiar, cortar y pegar.
 			\item soporte para la creación de gráficos y ventanas del sistema.
 			\item soporte para la gestión de eventos \emph{multitouch} y eventos realizados al pulsar la pantalla con más de un dedo.
			 \item soporte para la creación de contenido tanto de texto como de web.
 			\item soporte para la creación de controles y objetos del sistema.
 			\item soporte para la accesibilidad de aplicaciones.
 			\item soporte para el acceso a las capacidades hardware del dispositivo: batería, cámara, acelerómetros, sensor de proximidad \ldots 
 		\end{itemize}
 	 \item [Foundation.] Es un \emph{framework} heredado de la plataforma OS X. Provee el soporte para las siguientes funcionalidades: % \fxnote{funcionalidades mejor?}:
 		\begin{itemize}
			\item colecciones de datos (arrays, sets \ldots)
			\item gestión del tiempo y fechas.
			\item gestión de las preferencias del dispositivo.
			\item gestión de URLs.
			\item internacionalización del dispositivo.
		\end{itemize}
	\item [Address Book UI.] Una de las partes más importantes en un dispositivo móvil es la agenda de contactos. Nos proporciona las herramientas necesarias para gestionar toda la interfaz de usuario relacionado con el acceso a los contactos del dispositivo.
	\item [Message UI.] Proporciona el soporte necesario para componer y gestionar mensajes de correo electrónico en nuestras aplicaciones.
	\item [Map kit.]  Esta interfaz proporciona la creación de una vista de un mapa geográfico escalable con posibilidad de incrustar en él información detallada. Un típico ejemplo es la localización en un mapa de un restaurante.
	\item [Game Kit.] Nos permite añadir a nuestras aplicaciones el soporte de comunicaciones \emph{peer-to-peer} o redes dos a dos. Especialmente importante en aplicaciones  o juegos multiusuario.
	\item [Push Notification Service.] Proporciona un camino para notificar a los usuarios que una aplicación tiene nueva información relevante. El sistema notifica al usuario la información incluso si la aplicación no está en ejecución.

\end{description}

 Para poder desarrollar aplicaciones para dispositivos iOS, Apple pone a disposición de forma gratuita un conjunto de herramientas de desarrollo (SDK) que se encuentra disponible en su portal web. %\fixme{No entiendo.}

%PACO CAMBIA ESTO 
\begin{afixme}
  Entiendo que la parte más importante, en lo que afecta a la  aplicación, de todo lo que has contado es el UKit y quizá algo del Foundation. Tendrás que hablar en algún momento sobre en qué forma influye en la arquitectura final y porqué y para ello es probable que antes ofrezcas algún dato extra sobre sus típicos usos, incluso algún ejemplo. No lo tengo claro, estoy pensando en el lector y aún no he leído el resto así que puedo estar equivocándome.
\end{afixme}

\section{Arquitectura del API de Betfair}

	El API de Betfair está diseñado bajo un protocolo \emph{SOAP}\footnote{Simple Object Access Protocol: es un protocolo estándar que define cómo dos objetos en diferentes procesos pueden comunicarse por medio de intercambio de datos XML.} % CAMBIA ESTO
	\fixme{Esto hay que solucionarlo mediante una referencia bibliográfica utilizando bibtex, pregunta si no sabes cómo y lo vemos juntos.} que esta disponible a través de una conexión web HTTPS\footnote{Hypertext Transfer Protocol Secure segura.} \fxnote{Lo mismo}.  

%\fixme{Creo que se hace fundamental explicar en qué consiste todo este asunto del WSDL, cómo se usa (probablemente hay varios ``workflows'' posibles), un par de ejemplos pueden ser determinantes para entender la filosofía. En estos %momentos, como lector, estoy más interesado en que me cuentes cómo se materializa ese API que en ningún otra cosa. También puedes dar el ejemplo un poco más adelante y avisar al lector. Puedes utilizar subsections para organizar %bien la exposición.}

          El API está disponible a partir de un fichero en formato WSDL\footnote{Web Services Description Language, un formato XML que se utiliza para describir servicios Web.} en el portal de desarrolladores de Betfair. Dicho formato describe la interfaz para todos los servicios web disponibles de Betfair. Un programa cliente que se conecta a un servicio web puede leer el WSDL para determinar qué funciones están disponibles en el servidor. Los tipos de datos especiales se incluyen en el archivo WSDL en forma de XML. El cliente puede usar SOAP para hacer la llamada a una de las funciones listadas en el WSDL. En el capítulo \ref{ch:implemetacion} describiremos cómo hemos hecho uso de este fichero para construir las llamadas al servidor y consumir dichos servicios de Betfair.
          
 Los servicios proporcionados por el API se dividen en dos conjuntos: 
          
\begin{itemize}
	\item Global: contiene todas las llamadas referentes a los servicios básicos de Betfair, tales como el inicio de sesión, la administración de tu cuenta Betfair, tus fondos y las llamadas para navegar por los diferentes eventos disponibles en el portal de apuestas.
	\item Exchange: contiene las llamadas a los servicios relacionados con las apuestas, es decir, apostar por un evento, descripción de los mercados disponibles, actualización o cancelación de las apuestas ya realizadas, historial de todas nuestra apuestas \ldots %\fxnote{usa ldots: \ldots}
\end{itemize}
%\begin{figure} [h]
 % \centering

 % \begin{afixme}
 %   ¿Para qué sirve esta figura?
%  \end{afixme}

    %\includegraphics[width=0.6\textwidth]{./images/DeveloperBetfair.png}
  %\caption{API Betfair}
  %\label{fig:API Betfair}
%\end{figure}

  Para cada conjunto existen dos formas de acceso al API:
\begin{description}
	\item [Free Access API.]  Con este acceso tendremos disponibles los servicios básicos del portal y las herramientas suficientes para poder apostar por los eventos disponibles. Gratuito pero con acceso limitado a las llamadas de los servicios.
	\item [Full Access API.] Acceso de pago donde están disponibles los servicios exclusivos del portal tales como la información avanzada de los mercados, la gestión avanzada de nuestra cuenta de usuario\ldots Se gestiona a partir de una cuota anual y no existen límites en las llamadas a los servicios del API.
\end{description}


%\fixme{Este aspecto creo que es importante y que debe resaltarse en una subsection.}

%\fxnote{Quizá aquí puedes dar más detalles sobre SOAP, WSDL su uso en general y el nuestro en particular.}

    Resaltar en este apartado que dado que nuestra aplicación no soporta la plataforma WSDL, hubo que implementar cada llamada a los servicios de Betfair bajo la tecnología de Apple y su posterior serialización para el tratamiento de datos de la aplicación. Por cada llamada descrita en el archivo de definición de servicios hemos tenido que implementar la estructura de la comunicación mediante mensajes XML\footnote{Extensible Markup Language, es un metalenguaje extensible de etiquetas desarrollado por el World Wide Web Consortium (W3C).}, uno de petición y otro de respuesta con un parser asociado que traduzca dichos mensajes. En el capítulo \ref{ch:implemetacion} veremos con más detalle la adaptación de WSDL a la plataforma iOS.

    Los servicios básicos que hemos usado para el desarrollo de la aplicación han sido:

%\fixme{Yo elegiría una tipografía específica para nombrar cada servicio. Puede bastar con lstinline.}
\begin{itemize}
	\item \lstinline{Login}: 
		llamada para poder usar los servicios web de Betfair. 
	\item \lstinline{GetActiveEventTypes}: 
		con esta llamada obtenemos todos los eventos deportivos actualmente en marcha por los que se puede apostar.
	\item  \lstinline{GetAllMarkets}:
		con esta llamada obtenemos todos los mercados referentes a un evento.
	\item  \lstinline{GetCurrentsBets}:
		llamada por la cual obtenemos todas las apuestas activas que hemos realizado.
	\item  \lstinline{GetMarketPrices}:
		obtenemos los precios (back y lay) actuales por un evento determinado.
	\item  \lstinline{GetMarket}:
		esta llamada nos devuelve todos los datos referentes a un mercado.
	\item  \lstinline{PlaceBets}:
		con esta llamada enviamos una apuesta a Betfair.
	\item  \lstinline{ViewProfile}: 
		esta llamada nos devuelve los datos de perfil de usuario.
	\item  \lstinline{RetrieveLIMBMessage}:
		 con esta llamada obtenemos los mensajes del sistema pendientes de acción por parte del usuario.
\end{itemize}

\section{Arquitectura de la aplicación}
%\fixme{Las comillas en LaTeX se escriben ``así''.}

 Para el diseño de la arquitectura nos hemos basado en el patrón de diseño ``Modelo Vista Controlador (MVC)''. Dicho patrón es muy utilizado en la programación orientada a objetos, donde los objetos del modelo representan los datos de la aplicación y son persistentes. Fundamentalmente consiste en separar los datos de una aplicación, la interfaz de usuario, y la lógica de control en tres componentes distintos:
 
 
 \begin{description}
 	\item [Modelo.] Es la representación de toda la información con la cual el sistema trabajará. El modelo es independiente de cualquier representación o vista.
	\item [Vista.] Se encarga de presentar el modelo en un formato adecuado para interactuar, normalmente mediante una interfaz de usuario.
	\item [Controlador.] Se encarga de responder a eventos. Esto implica cambios en el modelo y en la vista.
\end{description}
 
  La razón del uso de este patrón se debe a dos cuestiones fundamentales:
\begin{itemize}
	\item La facilidad entre la comunicación del %\fxnote{entre-entre?}
	modelo de datos y la interfaz. Añadir también que cualquier cambio en la interfaz de usuario no afecta al resto del modelo, por lo que se gana en facilidad a la hora de seguir desarrollando la solución en el futuro.
	\item Apple, en el uso de las herramientas de desarrollo del SDK, recomienda el uso de dicho patrón para la creación de la interfaz de usuario de la aplicación. Esta recomendación es debido a la arquitectura interna del iOS y a que sus herramientas de desarrollo también están orientadas a esta solución.
	\item La estructura jerárquica de los datos obtenidos a través del API de Betfair. Este patrón nos facilita la representación de los mismos.
\end{itemize}

%\fxnote{MVC es un nombre demasiado genérico y bastante manido, quizás quieras explorar con más profundidad las características exactas del patrón que hayas aplicado: http://www.aspiringcraftsman.com/2007/08/interactive-application-architecture/, http://c2.com/cgi/wiki?MvcIsNotObjectOriented}

\subsection{Núcleo de la aplicación}
	Toda aplicación para iOS se desarrolla usando principalmente el \emph{framework} UIKit. UIKit proporciona todo lo necesario para lanzar la aplicación, coordinar los \emph{inputs} del usuario y mostrar el contenido en la pantalla. 
	Desde que el usuario pulsa el icono de la aplicación hasta que esta es ejecutada , el \emph{framework} UIKit gestiona todo lo necesario para lanzar la infraestructura. Toda aplicación recibe principalmente eventos continuamente desde el sistema y debe responder a todos estos eventos. 
	
	El ciclo %\fxnote{``ciclo de vida'' es un término ambiguo, si lo puedes evitar mejor.} 
	de una aplicación esta formado por la secuencia de eventos (pulsación en la pantalla por parte del usuario, llegada de un mensaje\ldots ) %\fxnote{¿Qué es un evento?}
	 que ocurren entre el inicio %\fxnote{ejecución? quieres decir durante? quieres decir inicio?}
	 y la finalización de la aplicación. En iOS, el usuario lanza la aplicación pulsando sobre el icono de la misma.  A partir de este momento, UIKit es el encargado de lanzar la interfaz de usuario y de leer los eventos que se produzcan en un bucle hasta que la aplicación sea finalizada bien por el sistema o bien por el usuario. Durante el bucle, UIKit coordina la llegada de eventos a los objetos que determinemos (el usuario pulsa una parte de la pantalla) %\fxnote{qué significa ``determinemos''?}
	 y coordinar las respuestas %\fxnote{¿qué es una respuesta?} 
	 de las mismas, es decir, qué hacer ante la acción del usuario. 
	     
 \begin{figure} [h]
  \centering
    \includegraphics[width=0.8\textwidth]{./images/app_life_cycle.jpg}
  \caption{Ciclo de una aplicación iOS }
  \label{fig:iOS-layers}
\end{figure}
     
   La figura \ref{fig:iOS-layers} %\fxnote{incluir la referencia a la figura: \ref{fig:iPhoneOS layers}}
    muestra el ciclo de una aplicación para iOS. Tal y como vemos, UIKit se encarga del arranque de la aplicación y de la gestión de eventos. Nuestro código será el encargado de gestionar esos eventos justo cuando reciba la notificación de que la aplicación ha sido lanzada. También podremos gestionar las accionas oportunas (guardar preferencias o cambios producidos en la aplicación) cuando UIKit nos notifique la finalización de la aplicación.
   
    En iOS sólo se finaliza una aplicación por tres motivos:
    \begin{itemize}
	\item El usuario finaliza la misma pulsando el botón \textsf{Home}. %\fxnote{Yo usaría tipografía para el UI, por ejemplo \textsf{Home}.}.
	\item El sistema recibe una notificación prioritaria que atender (una llamada por ejemplo) y por tanto finaliza la aplicación. %\fxnote{Qué brusquedad! ¿realmente finaliza la aplicación? ¿no la suspende o algo parecido?}
	\item El sistema detecta un comportamiento erróneo de la aplicación y para salvaguardar la estabilidad del sistema finaliza nuestra aplicación.
     \end{itemize}

    Es responsabilidad del desarrollador asociar a cada evento un método adecuado para gestionarlo. Si el desarrollador deja un evento sin asociar, la aplicación simplemente lo ignorará.
    
%\fixme{Dudas que me surgen y que no se si este es el sitio o el momento adecuado para resolverlas. Lo que sí se es que impactan en el diseño: ¿qué eventos llegan al ``Your code''? ¿Qué reglas existen para tratarlos? ¿Se enlazan los eventos a métodos? ¿Se puede modificar ese supuesto ``vector de interrupciones''? ¿Los eventos son independientes de los objetos gráficos? Seguro que contestas a estas preguntas más adelante pero a mi, como lector, me gustaría saber algo más ahora.}    
    
\subsection{Controladores de Vista}	   

%\fxnote{¿Qué es una vista? ¿Te refieres a vistas del MVC o del SDK del iphone? ¿te refieres a controladores del MVC o del SDK?}
 
 Un controlador de vista del SDK proporciona la lógica básica de interfaz de usuario para dibujar las vistas de la aplicación. Definimos como vista de usuario la pantalla que se le presenta en un momento dado. Apple dispone de varios patrones de interfaces de usuario para ayudar a representar el conjunto de datos hacia el usuario en las aplicaciones dentro de los dispositivos móviles. 
 
  Un controlador de vistas gestiona la vista de nuestra aplicación que aparece entre las barras superiores e inferiores (véase figura \ref{fig:layout-of-views}).%\fxnote{\ref{fig:layout-of-views}}). 
  La vista de la aplicación aparece entre la barra de estado y la barra de navegación si ésta está presente. En una vista de aplicación se muestra una parte de datos y controles que el desarrollador quiere mostrar al usuario en un tiempo determinado. El controlador de la vista simplemente gestiona la presentación de esta vista y la siguiente en aparecer para un patrón de diseño establecido.
 
 \begin{figure} [h]
  \centering
    \includegraphics[width=0.8\textwidth]{./images/vc-areas.jpg}
  \caption{Esquema de las vistas }
  \label{fig:layout-of-views}
  %\fixme{Cuidado con los labels, no debes utilizar blancos aunque puedes usar ``:'' y ``-'' y ``\_''. de hecho empezar por fig: es una convención.}
\end{figure} 
 
 Usando controladores de vista eliminamos el código redundante e innecesario en las aplicaciones %\fxnote{¿en qué sentido?}
  y proporcionamos una interfaz de usuario familiar %\fxnote{¿familiar al ser usada por ``todos'' los programadores?}
  hacia los usuarios acostumbrados a la interfaz del terminal. %\fxnote{usuario-usuario}. 
 Los controladores de vista nos ahorran código al automatizar la presentación de cada vista al usuario. % \fxnote{¿Qué quieres decir?}. 
 También ayudan al diseño orientado de objetos separando los detalles de la interfaz de usuario de la lógica de la aplicación.
 
  Como ya hemos comentado los controladores de vista soportan el patrón de diseño MVC. %\fxnote{Pero\ldots ¿cómo funciona?}.
  Todos los datos y la lógica de la aplicación se ha implementado usando el lenguaje orientado a objetos emph{Objective-C}, para una mayor facilidad a la hora de la implementación haciendo uso de las herramientas del SDK.% \fxnote{Francisco, esta frase no dice nada, ¿de qué otra forma podrías implementarlos en ObjectiveC? ¿Donde están esos datos? ¿En las vistas? ¿En los controladores? ¿Donde está el modelo?}. 
  %En este caso los controladores de vista son los encargados de proporcionar los métodos delegados (métodos de la vista que delegan el control al controlador) %\fxnote{¿qué es un método delegado?}
   %y la fuente de datos para las vistas de tipo tabla que explicaremos a continuación.
  
 \subsection{Controlador Vista de tablas}	

  Es muy común usar vistas de tabla para mostrar un conjunto de datos de tipo jerárquico unido a los controladores de navegación para poder recorrerlos.  %\fxnote{¿Quieres decir que para implementar un modelo de datos jerárquico utilizas tablas + controladores de navegación? ¿qué es un controlador de navegación?}. 
  Para ello, disponemos % \fxnote{Yo evitaría utilizar tanto la palabra ``Apple'', puedes decir ``Para ello disponemos\ldots{}''.} dispone
   de una plantilla o ejemplo en las herramientas del SDK % \fxnote{¿Qué es una plantilla?} 
   de controlador llamada ``Controlador de vistas de tabla'' que nos proporciona todo lo necesario para ello. En nuestra aplicación, tenemos que mostrar el modelo de datos que recogemos de los servidores de Betfair. Éstos están organizados de forma jerárquica, de lo más general a lo más específico. Para poder realizar una apuesta en un partido de fútbol concreto antes hemos tenido que elegir deporte, categoría, país, división y finalmente el partido.
 La mejor forma de representarlos es mediante una vista de tabla tal y como nos recomiendan las hojas de estilo de Apple. Es la figura \ref{fig:table-view-top} podemos ver un esquema representativo de la información más general.

%\fixme{Creo que es muy importante resaltar esta justificación y para ello hemos de hablar antes del modelo de datos que impone Betfair.}
  
 \begin{figure}[h!]
  \centering
    \includegraphics[width=0.7\textwidth]{./images/tv_datamodel_top.jpg}
  \caption{Vista de tabla del top de la jerarquía }
  \label{fig:table-view-top}
\end{figure} 

 En la figura \ref{fig:table-view-middle} nos encontramos una información de tipo jerárquica en la mitad de recorrido. Podemos asociarla al ejemplo de la elección de la división.

\begin{figure}[ht!]
  \centering
    \includegraphics[width=0.7\textwidth]{./images/tv_datamodel_middle.jpg}
  \caption{Vista de tabla de la mitad de la jerarquía}
  \label{fig:table-view-middle}
\end{figure} 

 A continuación representamos el final de nuestro recorrido por el modelo de datos. Como podemos observar en la figura \ref{fig:detail-table-view}, hemos alcanzado la información más específica.

\begin{figure}[ht!]
  \centering
    \includegraphics[width=0.8\textwidth]{./images/tv_datamodel_detail.jpg}
  \caption{Vista de tabla detallada del final de la jerarquía }
  \label{fig:detail-table-view}
\end{figure} 

%\fixme{Estas tres figuras así sueltas no aportan nada, tienes que explicar su significado y me parece superrelevante porque parece que con ello explicas cómo haces aparecer las listas en el iPhone.}

\subsection{Arquitectura de la aplicación}	
   
   Como ya hemos visto en apartados anteriores, la aplicación esta formada principalmente por un conjunto de controladores de vista más un módulo encargado de comunicarse con el API de Betfair. %\fixme{Fíjate que ésta es una decisión de diseño que aún no has explicado.}
   
   \begin{figure} [h]
     \centering
     \includegraphics[width=0.8\textwidth]{./images/modelo1.png}
     \caption{Esquema modelo vista controlador }
     \label{fig:esquema-MVC}
   \end{figure}
   
    En la figura \ref{fig:esquema-MVC} podemos ver un esquema del modelo Vista Controlador usado. % \fxnote{de la arquitectura?}.
     Los controladores de vista se encargan de recoger los eventos de la aplicación, principalmente \emph{inputs} del usuario. % \fxnote{eventos?}. 
     En el caso de que el input involucre datos de Betfair, el controlador envía los datos necesarios para que el módulo de comunicación obtenga la respuesta por parte del API de Betfair. 
    
\subsubsection{Controlador principal}

 Es la clase principal de la aplicación. Es la encargada de iniciar el controlador de vista que será encargado de recoger los eventos del usuario, así como la gestión de memoria y la gestión de los eventos del sistema.
 
\subsubsection{Controlador de menú principal}
 Es la encargada de mostrar las opciones principales del programa y recoger los inputs del usuario para lanzar el controlador adecuado a la elección del usuario. También se encarga de gestionar el inicio de sesión del usuario para los servicios web de Betfair. Para ello hace uso del servicio \emph{login} de Betfair a través de la clase de comunicación llamada API.
 
\subsubsection{Controlador de tipos de eventos}
 Muestra al usuario una lista con todos los tipos de eventos activos por los que se puede apostar dentro de Betfair. En un futuro se podrá gestionar por fecha de finalización, orden alfabético o búsqueda directa de eventos. Una vez seleccionado el evento deseado, se lanza el controlador de eventos y mercados con la información relativa al evento previamente seleccionado. Hace uso del servicio de Betfair \emph{GetActiveEventsTypes}  a través de la clase API del modelo de la aplicación.
 
\subsubsection{Controlador de eventos y mercados}

 Es la clase encargada de mostrar de forma jerárquica los subeventos y mercados relacionados con un evento seleccionado previamente en el controlador de eventos. Igualmente se podrá gestionar por fecha de finalización, orden alfabético o búsqueda directa de eventos. En caso de ser seleccionado un evento, se le mostrará los mercados y subeventos relacionados con los mismos. Si se selecciona un mercado se procederá a lanzar el controlador de información de mercado. Para ello recaba la información obtenida a través del servicio web \emph{GetEvents} de Betfair.
 
\subsubsection{Controlador de información de mercado}

 Es el responsable de gestionar toda la información relevante al mercado en cuestión. Gestionará el estado del mercado y sus propiedades obteniendo todo lo necesario del portal de Betfair a través del API de sus servicios web haciendo uso de las llamadas del API:
 
  \begin{itemize}
	\item \emph{GetMarket}: obtiene todos los parámetros acerca del mercado.
	\item \emph{GetMarketPrices}: obtiene todos los precios actuales del mercado en cuestión.
\end{itemize}

\subsubsection{Controlador de apuesta por un mercado}
 Gestiona todos los datos necesarios e introducidos por el usuarios para realizar una apuesta y enviarla a Betfair. El método usado para enviar la apuesta a Betfair a través de la clase interfaz de comunicación es \emph{PlaceBets}.

\subsubsection{Controlador de las categorías de Mis Apuestas}
 Es la clase encargada de gestionar las apuestas ya realizadas en Betfair y que siguen activas. Las clasifica por categorías de mercado. Recoge la información como resultado de las llamadas a los siguientes servicios web de Betfair:
  \begin{itemize}
	\item \emph{GetMarket}: obtiene todos los parámetros acerca del mercado de una apuesta en cuestión.
	\item \emph{GetCurrentBets}: obtiene todas las apuestas realizadas por el usuario del servicios Betfair.
\end{itemize}
 
\subsubsection{Controlador de Mis Apuestas}
 Esta clase se encarga de gestionar las apuestas realizadas por el usuario dentro de una categoría determinada. En ella se muestra resumidamente el nombre de la apuesta en cuestión, la cuota apostada y la cuota actualizada en ese momento. 

\subsubsection{Controlador de detalles de una apuesta}
 Se encarga de gestionar todos los detalles sobre una apuesta determinada: parámetros, stake, apuesta a favor o en contra relacionadas con la presentada\ldots También incluye información completa del mercado actual referente al mercado de la apuesta y el trading acerca de la misma.

 
\subsubsection{API: Interfaz a Betfair}
 Esta clase se encarga de gestionar las comunicaciones con los servidores de Betfair. Envía las peticiones a los servicios web de Betfair y se encarga de realizar la decodificación de la respuesta a dichas peticiones en un formato adecuado para la aplicación.

\section{Diagrama de Clases}
 En la siguiente figura podemos ver el diagrama de clases del proyecto. Observamos que el núcleo de esta aplicación es la clase ``API". Como bien hemos descrito es la encargada de comunicarse con el servidor de Betfair tanto para enviar las peticiones como de procesar las respuestas. Esta clase necesita un \emph{parser} de XML para obtener los datos del mensaje de respuesta, de esta tarea se encarga la clase ``ParserXML''.
 
  A partir de ahí observamos que le rodean todos los controladores de vista de la aplicación, ya que son los que reciben las peticiones de la vista y la envían a la clase ``API''. ``RootViewController'' es la clase principal. Se lanza cuando se carga la aplicación y es la encargada de procesar el menú de la misma.

 \begin{figure}[h!]
    \centering
       \includegraphics[width=1.2\textwidth]{./images/DiagramaDeClases3.png}
     \caption{Diagrama de clases}
   \label{fig:Diagrama de clases}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementación}
\label{ch:implemetacion}
 En este capítulo se describirán todos los detalles relativos a la implementación de la aplicación. Empezaremos detallando el entorno de ejecución y el lenguaje de programación usado para su desarrollo y terminaremos destacando los detalles relevantes de la implementación.
 
\section{Entorno de ejecución}
 La aplicación desarrollada se ejecuta en un entorno llamado \emph{Cocoa Touch}. Cocoa es un conjunto de frameworks orientados a objetos que proporcionan un entorno de ejecución para las aplicaciones que se ejecutan en el sistema operativo iOS. Este entorno de desarrollo nos facilita a los desarrolladores la tarea de pasar de la etapa de diseño a la etapa de desarrollo para crear una aplicación. Cocoa Touch proviene del entorno de la plataforma \emph{Mac OS}, entorno de la que dependen los equipo de sobremesa de Apple. Se puede decir que es la misma plataforma añadiendo el soporte para los eventos táctiles y orientados a la tecnología móvil. 
 
 Como ya hemos comentado, Cocoa presenta dos caras: 
 \begin{itemize}
	\item Entorno de ejecución: las aplicaciones desarrolladas en Cocoa presentan la interfaz de usuario de la aplicación y están fuertemente integradas con otras partes del sistema operativo como por ejemplo el buscador del sistema de ficheros.
	\item Entorno de desarrollo: Cocoa es una suite de componentes software que están orientados a objetos y que te permiten rápidamente crear robustas y completas aplicaciones para el sistema operativo.
\end{itemize}
  
 \begin{figure}[ht!]
    \centering
       \includegraphics[width=0.9\textwidth]{./images/architecture_stack.jpg}
     \caption{Entorno iOS }
   \label{fig:iOS Platform}
\end{figure}
 
 A pesar de que la estructura del iOS es similar a la de la plataforma Mac OS, existen diferencias significantes. El diagrama del iOS muestra una plataforma como una serie de capas que van desde en núcleo de sistema operativo hasta un conjunto de frameworks de aplicación, la más crítica (para las aplicaciones) empieza con la capa UIKit.
 
 Para desarrollar en entornos Cocoa se utiliza el lenguaje \emph{Objective-C}. Este lenguaje está basado en la programación orientada a objetos. Se define como un superconjunto del lenguaje de programación \emph{C}, es decir, podemos considerarle como una fina capa que complementa a C. La sintaxis de objetos de Objective-C deriva de \emph{Smalltalk}\footnote{Smalltalk es un lenguaje de programación que permite realizar tareas de computación mediante la interacción con un entorno de objetos virtuales.}.
 
  Como todo lenguaje de programación orientado a objetos, Objective-C nos proporciona principalmente:
 \begin{itemize}
	\item Un lenguaje de programación orientado a objetos.
	\item Una extensa librería de objetos.
	\item Una conjunto software de herramientas de desarrollo.
	\item Un entorno de ejecución propio.
\end{itemize}

 Aparte de las características propias del lenguaje, al estar basado en el lenguaje C, su compilador es capaz de ejecutar líneas de código codificadas en C. Esta característica permite usar librerías realizadas en C en programas desarrollados en Objective-C. 
 
\section{Estructura de la aplicación}
 Cuando construimos una aplicación para el sistema operativo iOS usamos la herramienta que nos proporciona el SDK de Apple \emph{Xcode}. Es un editor software que contiene todos lo necesario para compilar proyecto escrito en Objective-C. La ventaja de usar este editor y no uno universal que acepte dicho lenguaje de programación es que Xcode es capaz de implementar nuestra aplicación en lo que llamamos un paquete. Este paquete es un directorio en el sistema de ficheros que agrupa los recursos necesarios para la aplicación en un mismo lugar. Dicho paquete contiene el ejecutable y cualquier recurso usado por el mismo (por ejemplo, el icono de la aplicación, imágenes contenidas \ldots). La tabla \ref{fig:componentes} lista el contenido del paquete de esta aplicación.
 
\begin{tabularx}{15cm}{|lX|Xl|} 
\hline 
\rowcolor[gray]{0.9}Archivo & Descripción\\ 
\hline 
BetfairApp & El fichero ejecutable de la aplicación. El nombre de este fichero es el mismo que el de la aplicación más la extensión app.\\ 
\hline 
Default.png & Imagen de 480 x 320 píxeles que se muestra nada más iniciarse la aplicación  a modo de introducción. El sistema usa esta imagen mientras realiza tareas en segundo plano que requieren de un tiempo sensible para el usuario.\\
\hline
Settings.bundle & Es un fichero que contiene las preferencias de la aplicación a personalizar por el usuario, como por ejemplo el lenguaje de la aplicación, el tipo de moneda a mostrar\ldots \\
\hline
iconBF.png & Icono de 57 x 57 píxeles que representa la aplicación en la pantalla principal del dispositivo. \\
\hline
Info.plist & También conocida como lista de propiedades. Este fichero es un lista donde se definen los valores claves de la aplicación tales como el identificador de aplicación, la versión y el título.\\
\hline
en.lproj & Archivo que contiene los textos de la interfaz en inglés. Usado por el sistema cuando este lenguaje esta por defecto para lanzar aplicación o definido en las preferencias de la aplicación.\\
\hline
es.lproj &Archivo que contiene los textos de la interfaz en español.\\
\hline
MainWindows.xib & Contiene la interfaz a cargar por defecto por el sistema una vez lanzada la aplicación. Contiene la ventana principal de la interfaz de usuario. \\
\hline
RootViewController.xib & Contiene los objetos necesarios de la interfaz de usuario del menú principal. \\
\hline
EventsControllerView.xib &Contiene los objetos necesarios de la interfaz de usuario del menú de los eventos activos. \\
\hline
EventsTypesControllerView.xib & Contiene los objetos necesarios de la interfaz de usuario de los tipos de eventos de Betfair. \\
\hline
EventsAndMarketsControllerView.xib & Contiene los objetos necesarios de la interfaz de usuario de los eventos y mercados disponibles. \\
\hline
MarketInfoControllerView.xib & Contiene los objetos necesarios de la interfaz de usuario de las características de un mercado. \\
\hline
PutBetControllerView.xib & Contiene los objetos necesarios de la interfaz de usuario de la realización de una apuesta. \\
\hline
MyBetsControllerView.xib & Contiene los objetos necesarios de la interfaz de usuario del menú de las apuestas ya realizadas por el usuario. \\
\hline
MyBetsCategoryController.xib & Contiene los objetos necesarios de la interfaz de usuario de las categorías de apuestas realizadas por el usuario. \\
\hline
MyBetsDetailsView.xib & Contiene los objetos necesarios de la interfaz de usuario con los detalles de una apuesta ya realizada y las opciones disponibles. \\
\hline
MyBetPropertiesView.xib & Contiene los objetos necesarios de la interfaz de usuarios de los datos del mercados en los que se realizó la apuesta con las opciones posibles a realizar sobre esta. \\
\hline
TradingController.xib & Contiene los objetos necesarios de la interfaz de usuario con los detalles acerca del trading sobre una apuesta. \\
\hline 
\label{fig:componentes}
\end{tabularx} 
  
  
 
\section{Internacionalización}
 Una parte importante a destacar en el proyecto es la posibilidad de establecer el lenguaje de la aplicación. Mediante la tienda de aplicaciones \emph{iTunes App Store} se puede distribuir la aplicación por diferentes países. Una aplicación del iPhone debe tener la posibilidad de poder mostrar varios lenguajes y tener uno por defecto. Cada lenguaje esta implementado en la carpeta X.lprj del paquete de implementación ya comentado en la figura \ref{fig:componentes}. En el conjunto para proporcionar el soporte a distintos lenguajes también se podrá especificar una imagen  de portada, icono de la aplicación, mensajes de alerta\ldots  adecuado al lenguaje escogido por el usuario. Por defecto, el sistema operativo iOS arranca la aplicación con los argumentos necesarios para que muestre la aplicación en el mismo lenguaje especificado en las preferencias del terminal, es decir, es el mismo lenguaje que esté configurado en éste. En caso de que no fuera posible, se procederá con el especificado por defecto de la aplicación.

  \begin{figure}[h!]
    \centering
       \includegraphics[width=0.5\textwidth]{./images/language.jpg}
     \caption{Ejemplo de la elección del idioma }
   \label{fig:Vista de las preferencias del idioma}
\end{figure}

 
  En esta implementación se procederá a dar soporte al español y al inglés, dos de los lenguajes más hablados dentro de la lista mundial.
  
  
  
  (ADJUNTAR IMAGEN COMPARATIVA ENTRE LAS DOS PANTALLAS, SILVIA NO TENGO PHOTOSHOP PERO EN ESTE FINDE LO INSTALO :) ). %ARRRR SACAR IMAGEN DEL TERMINAL
  
  
  
  Para implementar esta funcionalidad dentro de nuestro trabajo de fin de carrera hemos de definir la lista de palabras a traducir dentro de un archivo llamado \emph{Localizable.strings}. Este archivo se ubica dentro de la carpeta es.lpjr o en.lpjr según sea la tabla de traducción en inglés o en español. A continuación se muestra un ejemplo del contenido de dicho fichero.
  
\begin{lstlisting}[frame=single, language=xml,basicstyle=\small, keywordstyle = \color{blue}]
/* 
   Localizable.strings
   Betfair App

   Created by Francisco on 21/12/11.
   Copyright 2011  . All rights reserved.
*/
"Events" = "Eventos";
"My bets" = "Mis apuestas";
"My account" = "Mi cuenta";
"Announcements" = "Mensajes del sistema";
"Profile" = "Cuenta";
"Bet info" = "Info. apuesta";
"Your bet" = "Tu apuesta";
"Nothing" = "Vacio";
"Active events" = "Eventos activos";
"Available markets" = "Mercados disponibles";
"Bet for" = "Apostar por";  
\end{lstlisting}

   
\section{Interpretación XML de Betfair a Cocoa Touch}
 Como ya tratamos en el capítulo \ref{ch:diseno}, un tema clave a destacar es la adaptación del API de Betfair a la arquitectura del terminal iPhone. 
 
  Betfair ofrece el acceso a todos sus servicios a aquellos programadores que quieren incluirlos a través de aplicaciones. Es un camino eficaz para hacer llegar sus servicios a usuarios de otras plataformas o para usuarios expertos que requieran de una interfaz de usuario más experta, orientada a sus necesidades. Por supuesto que esta política requiere de un sistema de seguridad para evitar fraudes o ataque por parte de la comunidad de hackers.
   
  En el diseño de una aplicación que debe hacer uso de servicios ofrecidos por un sistema externo se necesita algún tipo de API o interfaz para acceder a los mismos. Lo primero a tener en cuenta es lo que se necesita para hacer uso de las funciones proporcionadas por el API. Para acceder a los servicios ofrecidos por Betfair, ya vimos que su interfaz de acceso se describía mediante un archivo en formato WSDL. Este tipo de archivo es muy común y se usa para describir interfaces públicas de acceso a servicios web. Está basado en XML y contiene la descripción de la forma de comunicación con el servidor que ofrece los servicios web, es decir, los requisitos, parámetros y formatos de los mensajes necesarios para interactuar con los servicios disponibles. 
   
   Existen herramientas en el mercado que traducen de forma automática el archivo WSDL en código fuente ahorrando al programador tiempo y excluyendo al mismo los aspectos más básicos de la comunicación. Siendo el iPhone una plataforma novedosa, no existe a día de hoy este tipo de herramientas por lo que se tuvo que afrontar el desarrollo de la comunicación con el servidor de Betfair.
      
   A continuación se muestra un ejemplo del proceso de comunicación con Betfair para, en este caso, hacer uso del servicio \emph{Login } definido en el archivo WSDL que ofrece Betfair. En él se muestra la descripción de los parámetros necesarios de la comunicación.
   
\begin{lstlisting}[frame=single, language=xml,basicstyle=\small, keywordstyle = \color{blue}]

   <xsd:complexType name="LoginReq">
        <xsd:sequence>
         <xsd:element name="ipAddress" nillable="false" type="xsd:string"/>
         <xsd:element name="locationId" nillable="false" type="xsd:int"/>
         <xsd:element name="password" nillable="false" type="xsd:string"/>
         <xsd:element name="productId" nillable="false" type="xsd:int"/>
         <xsd:element name="username" nillable="false" type="xsd:string"/>
         <xsd:element name="vendorSoftwareId" nillable="false" type="xsd:int"/>
        </xsd:sequence>
      </xsd:complexType>
\end{lstlisting}


   Para comenzar, construimos la estructura de los mensajes a enviar en formato XML, haciendo un esquema por cada servicio disponible. Para ello, se desglosó el archivo en varias partes. La primera fue establecer la dirección web donde enviar los mensajes. La segunda fue construir las estructuras XML de cada servicio web. Hay que recalcar que a cada servicio, lo normal, es tener dos mensajes. El primero donde hacemos la petición al servidor y el segundo la respuesta. Para este caso concreto, formato del mensaje en XML a enviar sería el siguiente:
 
\begin{lstlisting}[frame=single, language=xml,basicstyle=\small, keywordstyle = \color{blue}]
  <?xml version="1.0" encoding="UTF-8"?>
  <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns2="http://www.betfair.com/publicapi/types/global/v3/" xmlns:ns1="http://www.betfair.com/publicapi/v3/BFGlobalService/">
  <SOAP-ENV:Body>
  <ns1:login>
  <ns1:request>
  <ipAddress>0.0.0.0</ipAddress>
  <locationId>0</locationId>
  <password>xxxxxxxx</password>
  <productId>82</productId>
  <username>user</username>
  <vendorSoftwareId>0</vendorSoftwareId>
  </ns1:request></ns1:login>
  </SOAP-ENV:Body>
  </SOAP-ENV:Envelope> 
 \end{lstlisting}
 
  Una vez construido el cuerpo del mensaje, sólo nos hace falta conocer la dirección de destino para el mensaje HTML a enviar a los servidores de Betfair:
  
\begin{lstlisting}[frame=single, language=xml,basicstyle=\small, keywordstyle = \color{blue}] 
  	URL = "https://api.betfair.com/betex-api-public-ws/BFService";
\end{lstlisting}

  Con todo lo necesario se encapsula toda la información bajo un mensaje HTML y se envía a Betfair. 
  
  Para este caso concreto, una vez enviado el mensaje de petición esperamos la respuesta con el siguiente formato:

\begin{lstlisting}[frame=single, language=xml,basicstyle=\small, keywordstyle = \color{blue}] 
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:n2="http://www.betfair.com/publicapi/types/" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<soap:Body>
<n:loginResponse xmlns:n="http://www.betfair.com/publicapi/BFService/">
<n:Result xsi:type="n2:LoginResp">
<header xsi:type="n2:APIResponseHeader">
<errorCode xsi:type="n2:APIErrorEnum">OK</errorCode>
<minorErrorCode xsi:nil="1"></minorErrorCode>
<sessionToken xsi:type="xsd:string">6XbAFn0tqfGgdWtQhRmspOctTJGPDOF0Unr2+5WWngk=</sessionToken>
<timestamp xsi:type="xsd:dateTime">2009-11-23T11:39:45.644Z</timestamp>
</header>
<currency xsi:type="xsd:string">EUR</currency>
<errorCode xsi:type="n2:LoginErrorEnum">OK</errorCode>
<minorErrorCode xsi:nil="1"></minorErrorCode>
<validUntil xsi:type="xsd:dateTime">0001-01-01T00:00:00.000Z</validUntil>
</n:Result>
</n:loginResponse>
</soap:Body>
</soap:Envelope>
 \end{lstlisting}
 
  Si observamos los campos \emph{errorCode} vemos que se reciben en ambos casos un \emph{OK} al envío anterior. Una vez comprobado la coherencia en la respuesta a salvo de fallos de recepción se procede a descifrar la respuesta. Para ello, se implementó un parser que convierte este mensaje en una estructura de datos válida para nuestra aplicación.  Este se procesa y se muestra al usuario la información recibida en un formato más adecuado. En la figura \ref{fig:proceso} se muestra el procedimiento completo del proceso.
       
 \begin{figure}[h!]
    \centering
       \includegraphics[width=1.2\textwidth]{./images/modelo_accion.png}
     \caption{Ejemplo de comunicación API }
   \label{fig:proceso}
\end{figure}
 
    
    Toda la aplicación gira en torno a este proceso. Sin él es incomprensible el resto del aplicativo. Es en él donde obtenemos los datos directamente de BetFair. Es lógico tratarlo así ya que las aplicaciones móviles suelen usar siempre servicios web y por tanto necesitan de conectividad. Esta aplicación no guarda información alguna salvo las credenciales de acceso al servicio. En una aplicación móvil nos interesa que la información que se necesita esté disponible cualquiera que sea el lugar donde nos encontremos. En el contexto de las apuestas lo más importante es tener la información lo más actualizada posible, es por eso que no se guarda la información de los mercados. Eso sí, tendría sentido quizá dotar en un futuro a la aplicación de una caché ,opcional a la elección del usuario, con caducidad para, por ejemplo, minimizar el consumo de batería del dispositivo en el caso que se necesitase.  
   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusiones}
\label{ch:conclusiones}

 En el presente trabajo de Fin de Carrera se ha documentado el proceso de diseño y  creación de una herramienta software para manejar apuestas bajo los terminales móviles iOS. 
 
El punto más importante del presente trabajo ha sido el portado de un servicio web originalmente diseñado para el mundo de navegadores web de PC a una plataforma móvil de última generación. En este trabajo de fin de carrera se ha elegido el API de Betfair y podemos concluir que su portado ha sido exitoso. La clave de este éxito ha sido el diseño e implementación de un parser, que hace de nexo de unión entre el servidor de Betfair y la aplicación, que realiza las funciones de un codificador y encapsulador de datos.
 
 Se han implementado los servicios básicos del API. Está limitación de servicios se ha debido al tipo de licencia elegido. Por este motivo se ha diseñado, desde el primer momento, una aplicación de tipo modular para que en un futuro se agreguen el resto de las funcionalidades sin ningún tipo de complicación. La arquitectura del desarrollo permite este tipo de ampliaciones siguiendo las técnicas de software específicas.
 
 Un hecho importante, diferenciador y clave en este trabajo es la implementación de la funcionalidad de trading. La aplicación es capaz de recalcular las condiciones del mercado basándose en una apuesta ya realizada y asistir al usuario para una ganancia segura o minimizar la pérdida según la evolución del mercado. La arquitectura de la aplicación esta diseñada para que en un futuro cercano se pueda desarrollar esta funcionalidad para que se realice sobre múltiples eventos y mercados.
 
 Se ha conseguido no almacenar información localmente redundante de la aplicación. Debido al uso de servicios web todos los datos de consulta y de generación por parte del usuario se guardan en el servidor. Por lo tanto, si el usuario usa alguna otra aplicación en otra plataforma no sería necesario ningún mecanismo de sincronización de información. En este tipo de contextos es mejor disponer de datos lo más actualizados posibles directamente desde el servidor que manejar una caché de datos desactualizadas al poco tiempo de descargarse del servidor. Los mercados están en continua evolución.
 
 Otra decisión de diseño importante ha sido la implementación de la internacionalización de la aplicación. La aplicación estará disponible a través de la tienda iTunes Store. Esta tienda tiene un acceso mundial y debido a ello se ha adoptado los principales idiomas para que la aplicación sea lo más extendida posible. 
 
\section{Trabajo futuro}
 Como ya hemos visto en la arquitectura de la aplicación, el sistema está preparado para posibles futuras funcionalidades extras que podemos aportar con los datos que nos ofrece el API. Debido a que el núcleo de la aplicación es la obtención y proceso de la información contenida en Betfair, cualquier desarrollador puede añadir una funcionalidad extra usando los datos anteriores y acoplarlas fácilmente a la arquitectura de la aplicación. Al usar el modelo vista-controlador, la sencillez a la hora de implementar nuevas funcionalidades está mas que probada.
 
\subsection{Trading global por lista de eventos}
 Una mejora interesante a implementar en un futuro sería la de poder realizar trading sobre un mercado entero. Al principio del presente trabajo hemos definido el trading como apostar a favor y en contra de un evento determinado para, según nuestra primera apuesta, obtener beneficio seguro o minimizar la pérdida. Pero, apostar a favor de un evento ¿puede suponer que éste afecte al resto del mercado? Pongamos un ejemplo, supongamos que estamos apostando por quién va a ser el campeón del mundial de Sudáfrica. Apostar a favor de un equipo puede llevar la consecuencia de apostar en contra de los restantes participantes si en vez de pensar en un equipo concreto pensamos en el mercado completo. 
 
  Este cambio en nuestro planteamiento supone llevar a cabo un gran control sobre todas las variables que afectan al mercado completo y no sólo por un evento. Para poder analizar completamente los datos de mercado (cuota y precio) necesitamos analizar los datos concretos de cada evento de dicho mercado. Para poder obtener cual sería el conjunto de apuestas a realizar en el mercado para obtener el beneficio tenemos que resolver un conjunto de ecuaciones linealess que representan al mercado cuyas incógnitas serán las cuotas y cantidad a apostar por cada eventos de dicho mercado.
   
    Incluir ejemplo de información de todo el mercado
    
  
 Normalmente los mercados tienen unos 30 eventos. Para poder obtener una solución óptima tenemos que echar mano de herramientas de software de resolución de ecuaciones lineales, tales como \emph{zympl} y \emph{glpsol}. 
  
  
  
   La idea es tener una máquina servidora capaz de realizar estos cálculos cada, pongamos por ejemplo, una hora. Se trata de analizar continuamente el mercado para encontrar el momento idóneo para el trading global. El incluir otra máquina a parte del terminal es debido a la restricción de la batería. Si hiciéramos uso del terminal para estos cálculos reduciría drásticamente la vida útil de la misma. La máquina avisaría a la aplicación móvil del terminal en cuanto encontrase una solución adecuada a los parámetros configurados. 
   
    El procedimiento por el cual el usuario es notificado con la solución es implementar la solución de mensajería tipo push de Apple en el iPhone. A continuación mostramos como son las notificaciones en el terminal, también como mejora a añadir al proyecto.
    
 \subsubsection{Notificación por mensajes Push de Apple}
   
   En un modelo típico de cliente-servidor, el cliente es el encargado de contactar con el servidor para la descarga de nuevos datos, como por ejemplo el servicio de correo electrónico. En un dispositivo móvil, el cuál siempre tiene el inconveniente de la batería, esta solución no es válida debido al consumo energético en cada consulta al servidor. Para estos casos las notificaciones push son las solución a este dilema. Una notificación push es un mensaje corto que el servidor envía al cliente para notificarle que tiene datos para ser descargados o eventos pendientes tales como nueva versión de la aplicación. 
   
    Cuando un dispositivo móvil recibe una notificación de una aplicación que no está ejecutada en ese momento, el sistema notifica al usuario a través de un mensaje de alerta, un sonido determinado o un número indicador en el icono de la aplicación (o una combinación de este conjunto) de un evento a tratar por parte del usuario. El usuario, en todo momento, tiene la posibilidad de ejecutar la aplicación para obtener los datos notificados o simplemente ignorar el mensaje.

     \begin{figure}[h!]
    \centering
       \includegraphics[width=0.2\textwidth]{./images/badged_app.jpg}
     \caption{Alerta 1 }
   \label{fig:Alerta 1}
\end{figure}

\begin{figure}[h!]
    \centering
       \includegraphics[width=0.3\textwidth]{./images/notif_msg_one_button.jpg}
     \caption{Alerta 2 }
   \label{fig:Alerta 2}
\end{figure}

\begin{figure}[h!]
    \centering
       \includegraphics[width=0.3\textwidth]{./images/alert.jpg}
     \caption{Alerta 3 }
   \label{fig:Alerta 3}
\end{figure}

     
    Brevemente explicaremos el proceso completo del envío de un mensaje desde el servidor hasta la aplicación cliente del terminal. 
    
    En todo el proceso intervienen 3 actores: el servidor que desea entregar un mensaje, el servidor de Apple de envío de mensajes y la aplicación cliente.
    
 \begin{figure}[h!]
    \centering
       \includegraphics[width=1.1\textwidth]{./images/remote_notif_simple.jpg}
     \caption{Proceso general }
   \label{fig:Notificacion proceso}
\end{figure}
   \subsubsection{Registro}

     El primer paso del proceso es el registro de la aplicación en el servidor de Apple para activar el servicio de notificaciones. Tal y como se muestra en la figura \ref{fig:Notificacion Registro}, la aplicación cliente se conecta al \emph{APNS}\footnote{Apple Push Notification Server, el servidor encargado de recibir y enviar el mensaje de un tercero a un terminal iphone} para la obtención de un identificador (token) único para cada aplicación cliente y terminal. El APNS, después de comprobar las credenciales del terminal, genera y registra el token a partir del ID del dispositivo y devuelve al terminal su token generado. Este token identifica al terminal y por lo tanto lo ha de usar nuestro servidor para poder enviar a este terminal un mensaje push. Por eso, el último paso del registro es notificar al servidor desde el terminal el token generado para su registro interno.
     
 \begin{figure}[h!]
    \centering
       \includegraphics[width=0.8\textwidth]{./images/token_generation.jpg}
     \caption{Registro }
   \label{fig:Notificacion Registro}
\end{figure}
  
     \subsubsection{Envío de una notificación}
     
     Tal y como se muestra en la figura \ref{fig:Notificacion envio} cuando el servidor requiere enviar una notificación a un cliente determinado para indicarle que dispone de datos nuevos que descargar, éste envía el mensaje en cuestión junto con el identificador del terminal al APNS. El servidor APNS comprueba que el token ha sido generado por un certificado válido y que identifica a un terminal registrado previamente. Si todo esta correcto le envía el mensaje a la aplicación cliente del terminal.
     
 \begin{figure}[h!]
    \centering
       \includegraphics[width=0.8\textwidth]{./images/token_trust.jpg}
     \caption{Envío}
   \label{fig:Notificacion envio}
\end{figure}

 Como podemos ver, mediante estas notificaciones podemos tener al cliente lo más actualizado posible minimizando el gasto de batería si le tuviese que conectar periódicamente con algún servidor.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "castellano"
%%% End: 

